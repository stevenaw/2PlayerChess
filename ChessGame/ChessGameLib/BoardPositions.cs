using System;
using System.Collections.Generic;

namespace ChessGameLib
{
    /* The BoardPositions class, this acts as a collection of various board positions in a game.
     * This list is stored internally as a collection of board positions, each of which is mapped
     * to the number of times it has occured so far. This is used for the detection of board position
     * duplication as well the persistence of draw-related action. Draw-related action is essentially
     * the '50-move' rule, in which no piece is captured for 50 complete moves. This magic number, 50,
     * is supplied to the constructor as the capacity variable.
     * 
     * Each position is stored as a sequence of 64 characters as a string, stored in row-major order.
     * Each square is represented by the piece's algebraic notation, with side being determined by the
     * character being upper or lower case. Empty squares are represented by a class constant.
     */
    class BoardPositions : SortedList<String, int>
    {
        #region Variables and Constants
        // The maximum legal different board positions
        int capacity;

        // Number of moves since capture or pawn movement
        int occurences;

        // The symbol in the hash for an empty square
        private const char EMPTY_SQUARE = '0';

        // The number of repeated positions, after which a draw can be claimed
        private const int REP_THRESHHOLD = 3;

        // The starting position on a board
        public const string DEFAULT_START = "rnbqkbnrpppppppp00000000000000000000000000000000PPPPPPPPRNBQKBNR";

        /*
         * Stores the string representation of the current board position.
         * After each move, this is compared to all elements of past board positions, with track being
         * kept of the number of prior occurences.
         */
        String currPos;
        public String CurrPosition
        {
            get { return this.currPos; }
        }

        /*
         * Running tally of the number of ply (one move by one side) since a pawn was moved or
         * piece captured. This is stored for draw detection purposes, since 50 full moves (100 ply)
         * constitutes a forced draw.
         */
        public new int Count
        {
            get { return this.occurences; }
        }
        #endregion
        #region ctor
        public BoardPositions(int capacity)
            : this(capacity, BoardPositions.DEFAULT_START)
        {
        }

        public BoardPositions(int capacity, String startPos)
        {
            this.capacity = capacity;
            this.currPos = startPos;
        }
        #endregion
        #region Public Methods
        #region Inherited Methods
        public new void Clear()
        {
            base.Clear();
            this.currPos = "";
            this.occurences = 0;
        }
        #endregion
        /*
         * Creates a custom hash of the board, uniquely representative of the exact
         * board position at that time. The product is stored internally, which is
         * compared to past positions to determine if a draw can be claimed.
         * 
         * The hash is generated by cycling through each square on the board and appending
         * a code onto a string. Empty squares are stored as 0, while occupied squares are
         * given their piece notation in lowercase for white and uppercase for black.
         * 
         * In the event that a hash exists of the board already, it is duplicated and updated
         * appropriately instead of complete generation from scratch.
         * 
         * After the hash is generated, it is stored in the SortedList and the counter for the
         * number of occurences of that position is incremented by 1;
         */
        public void add(ChessMove m, Board board)
        {
            char[] hash = new char[Board.NUM_SQUARES];

            // No position to build off of, generate
            if (this.currPos == String.Empty)
            {
                for (short i = 0; i < Board.NUM_ROWS; i++)
                    for (short j = 0; j < Board.NUM_FILES; j++)
                        if (board[i, j] == null)
                            hash[i * Board.NUM_ROWS + j] = EMPTY_SQUARE;
                        else
                            hash[i * Board.NUM_ROWS + j] = board[i, j].Colour == Piece.NOTATION_W ? Char.ToLower(board[i, j].Notational) : Char.ToUpper(board[i, j].Notational);
            }
            else
            {
                // Copy character from last position to this one
                this.currPos.CopyTo(0, hash, 0, hash.Length);
                hash[m.EndSquare.Y * Board.NUM_ROWS + m.EndSquare.X] = hash[m.StartSquare.Y * Board.NUM_ROWS + m.StartSquare.X];
                hash[m.StartSquare.Y * Board.NUM_ROWS + m.StartSquare.X] = EMPTY_SQUARE;
            }

            if (m.IsCapture || m.PieceMoved == (char)Piece.PieceNotation.Pawn)
                this.Clear();

            this.currPos = new string(hash);

            if (this.IndexOfKey(this.currPos) == -1)
                base.Add(this.currPos, 1);
            else
                this[this.currPos]++;

            this.occurences++;
        }

        /*
         * Checks if a draw has been forced as a direct result of movements
         * 
         * First, it is checked if enough moves have passed since the last capture or
         * pawn movement that a draw is claimed. After that, the current position of the
         * board is compared against all the past board positions since the last capture
         * or pawn move. If 3 matches are found, a draw is claimed. If neither condition
         * is met, a draw can not be claimed, and false is returned.
         */
        public bool isDrawByMoves()
        {
            // Draw due to inactivity or Repetition
            return this.occurences > this.capacity || this[currPos] == REP_THRESHHOLD;
        }

        #endregion
    }
}
